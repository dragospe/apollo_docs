{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Apollo Docs This is the documentation website for the Apollo project. Audience Are you a Developer? Study Coordinator? Contact For other inquires, email us.","title":"Apollo Docs"},{"location":"#apollo-docs","text":"This is the documentation website for the Apollo project.","title":"Apollo Docs"},{"location":"#audience","text":"Are you a Developer? Study Coordinator?","title":"Audience"},{"location":"#contact","text":"For other inquires, email us.","title":"Contact"},{"location":"study_coordinators/","text":"TODO: Data Retention and Privacy Policy Study Coordinator Documentation This documentation will guide you through enrolling a new subject into the Apollo-AF project. Briefly, you will need to: Enroll the subject in RedCAP. Create a Garmin Connect account for the subject. Authorize Apollo-AF to access the subject's data on Garmin Connect. Provide the subject relevant documents explaining our data retention and privacy policies. Step 1: Register the Subject in REDCap Click here to go to the REDCap website, or type the following URL in the address bar: https://redcap.urmc.rochester.edu/redcap/ Log-in using the dialog on the homepage. Under My Projects , click APOLLO-AF. Select Add / Edit Records from the nagivation bar: Click Add new record : and select the Enrollment button: and fill out the form presented. At this point you should verify that the subject was added successfully. You will also need the Subject (participant) ID. Navigate to the Record Status Dashboard using the navigation bar on the left. Locate the Participant ID of the subject you just enrolled. You will need this identifier later. Step 2: Register on Garmin Connect The portal provided by Garmin to allow us access to subject's wearable data requires an account on Garmin Connect . Because we do not want subjects manually entering data or changing settings on the Garmin Connect website, you (the study coordinator) will register accounts on behalf of the subjects. You should use an email of the form subject_000@apollo-af.org that is, the word \"subject\", followed by an underscore, followed by a three-digit form of the subject identifier from Step 1 (with leading zeros, if applicable). All emails sent to apollo-af.org are forwarded to a URMC-controlled email address. You do not need to create an email address before using it to register on Garmin Connect. Click here to navigate to the Garmin Connect sign in page, or type the following URL in the address bar: https://connect.garmin.com/signin Beneath the sign-in dialog, click the account creation link. Complete the form, and click \"Create Account.\" Please use a password manager to keep track of the passwords to individual accounts. Do not reuse passwords between accounts. Step 3: Authorize Apollo-AF Note: You may already be logged in to Garmin Connect from the prior step, or from other activities relating to this study. If you logged in to an account on Garmin Connect, you will not see the account information displayed. Make sure you are enrolling the correct account into the correct study. If you are unsure, clear your browser's cache or conduct this step in a private browsing window. If you need assistance, please ask. Click here to navigate to the Apollo-AF consent page, or type the following URL in the address bar: https://auth.apollo-af.org/oauth/garmin/consent Enter the Subject ID from step 1 when prompted: If you are still logged in to Garmin Connect from the previous step, will be automatically presented with the agreement form. If not, you will be prompted to enter the credentials for the account you created in step 2. Next, agree to the prompt. You will be redirected to auth.apollo-af.org , and should see a message reading You have successfully authorized us to monitor your Garmin data. If you do not see this message, something has gone wrong. Please notify us at apollo-af@urmc.rochester.edu . Step 4: Data Retention and Privacy Policy To do","title":"Study Coordinators"},{"location":"study_coordinators/#todo-data-retention-and-privacy-policy","text":"","title":"TODO: Data Retention and Privacy Policy"},{"location":"study_coordinators/#study-coordinator-documentation","text":"This documentation will guide you through enrolling a new subject into the Apollo-AF project. Briefly, you will need to: Enroll the subject in RedCAP. Create a Garmin Connect account for the subject. Authorize Apollo-AF to access the subject's data on Garmin Connect. Provide the subject relevant documents explaining our data retention and privacy policies.","title":"Study Coordinator Documentation"},{"location":"study_coordinators/#step-1-register-the-subject-in-redcap","text":"Click here to go to the REDCap website, or type the following URL in the address bar: https://redcap.urmc.rochester.edu/redcap/ Log-in using the dialog on the homepage. Under My Projects , click APOLLO-AF. Select Add / Edit Records from the nagivation bar: Click Add new record : and select the Enrollment button: and fill out the form presented. At this point you should verify that the subject was added successfully. You will also need the Subject (participant) ID. Navigate to the Record Status Dashboard using the navigation bar on the left. Locate the Participant ID of the subject you just enrolled. You will need this identifier later.","title":"Step 1: Register the Subject in REDCap"},{"location":"study_coordinators/#step-2-register-on-garmin-connect","text":"The portal provided by Garmin to allow us access to subject's wearable data requires an account on Garmin Connect . Because we do not want subjects manually entering data or changing settings on the Garmin Connect website, you (the study coordinator) will register accounts on behalf of the subjects. You should use an email of the form subject_000@apollo-af.org that is, the word \"subject\", followed by an underscore, followed by a three-digit form of the subject identifier from Step 1 (with leading zeros, if applicable). All emails sent to apollo-af.org are forwarded to a URMC-controlled email address. You do not need to create an email address before using it to register on Garmin Connect. Click here to navigate to the Garmin Connect sign in page, or type the following URL in the address bar: https://connect.garmin.com/signin Beneath the sign-in dialog, click the account creation link. Complete the form, and click \"Create Account.\" Please use a password manager to keep track of the passwords to individual accounts. Do not reuse passwords between accounts.","title":"Step 2: Register on Garmin Connect"},{"location":"study_coordinators/#step-3-authorize-apollo-af","text":"Note: You may already be logged in to Garmin Connect from the prior step, or from other activities relating to this study. If you logged in to an account on Garmin Connect, you will not see the account information displayed. Make sure you are enrolling the correct account into the correct study. If you are unsure, clear your browser's cache or conduct this step in a private browsing window. If you need assistance, please ask. Click here to navigate to the Apollo-AF consent page, or type the following URL in the address bar: https://auth.apollo-af.org/oauth/garmin/consent Enter the Subject ID from step 1 when prompted: If you are still logged in to Garmin Connect from the previous step, will be automatically presented with the agreement form. If not, you will be prompted to enter the credentials for the account you created in step 2. Next, agree to the prompt. You will be redirected to auth.apollo-af.org , and should see a message reading You have successfully authorized us to monitor your Garmin data. If you do not see this message, something has gone wrong. Please notify us at apollo-af@urmc.rochester.edu .","title":"Step 3: Authorize Apollo-AF"},{"location":"study_coordinators/#step-4-data-retention-and-privacy-policy","text":"To do","title":"Step 4: Data Retention and Privacy Policy"},{"location":"developers/","text":"Developers This is the developmer documentation resource for the various components of the Apollo-AF project. See the links below for specific information about the various repositories. Repositories apollo-ansible apollo_api apollo_db apollo_docs apollo_flask geneactiv redcap_qol_hacks","title":"Developers"},{"location":"developers/#developers","text":"This is the developmer documentation resource for the various components of the Apollo-AF project. See the links below for specific information about the various repositories.","title":"Developers"},{"location":"developers/#repositories","text":"apollo-ansible apollo_api apollo_db apollo_docs apollo_flask geneactiv redcap_qol_hacks","title":"Repositories"},{"location":"developers/projects/apollo-ansible/","text":"apollo-ansible Your one-stop-shop for deployment playbooks and info. Click here to see details about a specific role. Infrastructure Overview The current deployment is across two virtual servers from URMC's academic IT. It doesn't appear that we can reimage these, so don't fuck up. The first server is: apollosql.urmc-sh.rocheter.edu which houses: * a postgresql database cluster, with a database to store Garmin data and a database grafana uses for its backend * grafana * an nginx server to proxy requests to grafana and serve the static documentation site. The second server is: apolloweb.urmc-sh.rochester.edu which houses an nginx server that proxies requests to gunicorn/flask. Network Overview The below information is current as of 2020-01-30: apollosql Name: apolloweb.urmc-sh.rochester.edu IPv4 Address (Static): 172.168.139.232/22 Gateway: 172.16.139.250 DNS Servers: 172.17.254.30; 172.17.254.130 Firewalld services: dhcpv6-client http https postgresql ssh Nginx: listens on port 80, all names/addresses for redirects to https Listens on all addresses, port 443, on names: docs.apollo-af.org (served statically) dash.apollo-af.org (proxied to /grafana_socket/grafana.socket ) Postgresql: Listens on port 5432, all addresses. The user apollo is the only user allowed to connect over the network, and only to the apollo-site database. md5 authentication is used Listens on unix socket. The grafana and postgres users both use peer authentication. apolloweb NOTE: This server obtains its network info from DHCP!! It might change. We don't know. * Name: apolloweb.urmc-sh.rochester.edu * IPv4 Address (Static): 10.221.3.133/24 * Gateway: 10.221.3.250 * DNS Servers: 172.17.254.30; 172.17.254.130 * Firewalld services: dhcpv6-client http https ssh * Nginx: * listens on port 80, all names/addresses for redirects to https * Listens on all addresses, port 443, on name auth.apollo-af.org : * Location / is proxied to gunicorn, listening on localhost port 8000 * Location /api_client/garmin/ is proxied to gunicorn on localhost, port 8000. Garmin sends data using the following IPs, which are whitelisted: * 98.100.124.0/24 * 98.100.125.0/24 * 204.77.162.0/24 * 204.77.163.0/24 Users and groups The following users are added in the common role and should exist on all hosts. They are handled individually by the ansible scripts in the tasks/user_accounts/ directory. Currently the users that should exist on all hosts are: * apage2 (provided by Active Directory in the urmc-sh.rochester.edu domain) * pdragos (provided by Active Directory in the urmc-sh.rochester.edu domain) * apollo (local user) On apollosql , the users nginx and grafana (installed by their respective applications) should both be part of the grafana_socket group. This is necessary to allow nginx and grafana to communicate over a unix socket in a SGID directory. Crypto and Security Overview Passwords and keys should be stored in a password manager or ansible-vault'ed. * Postgresql communicates over TLS with self-signed cert. Authentication is either local ( peer ) or md5. * Grafana seems to require a plaintext database password in its configuration file. Care should be taken to ensure that the proper permissions are set on /etc/grafana/grafana.ini . * Nginx has individual TLS certificates for all host names it is responsible for. As of 2020-01-30, we do not have public IPs for the virtual machines; when we do, certbot will be responsible for maintaining these certificates. * A restrictive umask is in place. Be aware of this. * SELinux should work in enforcing mode. Deployment To get running quickly: * Set up your inventory file at hosts/prod/inventory . You'll need an apolloweb host and an apollosql host. * Run ansible-playbook -K deploy_to_prod.yml --vault-password-file /path/to/vault_pass -i hosts/prod/inventory Lifecycle Environments This repository is designed to configure development ( dev ), testing ( test ), and production ( prod ) lifecycle enviornments. To do so, three different inventory files in their respective directories under the hosts/[lifecycle state]/ directory. Variables specific to each lifecycle state may be set in accordance with inventory-based variables ( group_vars , host_vars , etc.) Note: In ansible, group_vars take precedence over variables in roles/[rolename]/defaults/main.yml . Playbook flow (current as of 2020-01-30): set up all servers ( apolloweb and apollosql with the common role cetup postgresql configure postgres do a hacky work-around to get SSL working set up nginx open ports set up the webapp set up grafana set up the documentation site Variables: Where to find them: hosts/[lifecycle state]/group_vars sets playbook-wide variables. This should be the primary source for configuration parameters. The playbook itself. This is where some more verbose, static parameters should be set (e.g., pg_hba.conf or the nginx.conf entries. Look at the relevant files to get an idea of the variables you need to set. Variables Variables that relate to site-wide or lifecycle-wide configuration are listed below. Complete descriptions of role-specific variables (required or optional) may be found in the respective README.md files. The variables listed below are generally defined in hosts/[lifecycle]/group_vars/all.yml . Variable Description Example lifecycle_state Either 'dev', 'test', or 'prod', depending on the inventory file used. prod apollo_site_database_name The name of the database the main API site will use apollo_site apollo_site_database_user The username that SQLalchemy/flask will connect as apollo apollo_site_database_password a vaulted password to authenticate the postgresql user for the main API site !vault | $ANSIBLE_VAULT;1.1;AES256 36643264643431346165613138326261356335326265353337363762663836653566336135303366 343365366... apollo_site_database_connection_cidr_ip The IPv4 address that the apollo site will connect to its backend database from, for whitelisting purposes 192.168.122.191/24 apollo_site_database_uri The URI that the SQLalchemy should use to connect to the database \"postgresql://{{ apollo_site_database_user }}:{{ apollo_site_database_password }}@apollosql.urmc-sh.rochester.edu:5432/{{ apollo_site_database_name }}\" apollo_monitor_domain The domain name (for grafana) dash.apollo-af.org apollo_monitor_root_url The full URL used for the site. Needed for redirects. https://dash.apollo-af.org/ apollo_monitor_postgresql_backend_host Controls how grafana accesses its backend database /run/postgresql/ apollo_monitor_postgresql_backend_database_name The name of the database grafana uses as its backend grafana apollo_monitor_postgresql_backend_database_username The username grafana connects to its backend database with grafana apollo_monitor_postgresql_backend_database_password The vaulted password grafana uses to connect to its backend database !vault |$ANSIBLE_VAULT;1.1;AES2560 353035646165360356233370... apollo_api_nginx_server_name The name that nginx listens on to proxy to the main site auth.apollo-af.org apollo_docs_nginx_server_name The name that nginx listens on to proxy to the documentation site docs.apollo-af.org apollo_monitor_nginx_server_name The name that nginx listens on to proxy to grafana dash.apollo-af.org Role Overview Role Description Pre-requisites apollo_api Sets up flask and gunicorn to serve the main site common, nginxinc.nginx apollo_docs Sets up the static mkdocs documentation site common, nginxinc.nginx apollo_monitor Configures a host to perform monitoring functions (grafana). common, nginxinc.nginx . Requires a a backend database, so some host must have the geerlingguy.postgresql and apollo_pg roles applied as well apollo_pg Configures a host running postgreSQL to function as apollo's long-term data store. Note: the geerlingguy.postgresql role must already be common, geerlingguy.postgresql apollo_scripts Configures a host to run scripts related to geneACTIV, medtronic, REDCap, etc. N/A common Common configuration applied to all hosts, including common software, user accounts, security hardening, etc. N/A geerlingguy.postgresql Configures a host with a postgresql server. Pulled from ansible-galaxy; do not modify. N/A nginxinc.nginx Configures a host with an nginx server. Pulled from ansible-galaxy; do not modify N/A","title":"apollo-ansible"},{"location":"developers/projects/apollo-ansible/#apollo-ansible","text":"Your one-stop-shop for deployment playbooks and info. Click here to see details about a specific role.","title":"apollo-ansible"},{"location":"developers/projects/apollo-ansible/#infrastructure-overview","text":"The current deployment is across two virtual servers from URMC's academic IT. It doesn't appear that we can reimage these, so don't fuck up. The first server is: apollosql.urmc-sh.rocheter.edu which houses: * a postgresql database cluster, with a database to store Garmin data and a database grafana uses for its backend * grafana * an nginx server to proxy requests to grafana and serve the static documentation site. The second server is: apolloweb.urmc-sh.rochester.edu which houses an nginx server that proxies requests to gunicorn/flask.","title":"Infrastructure Overview"},{"location":"developers/projects/apollo-ansible/#network-overview","text":"The below information is current as of 2020-01-30:","title":"Network Overview"},{"location":"developers/projects/apollo-ansible/#apollosql","text":"Name: apolloweb.urmc-sh.rochester.edu IPv4 Address (Static): 172.168.139.232/22 Gateway: 172.16.139.250 DNS Servers: 172.17.254.30; 172.17.254.130 Firewalld services: dhcpv6-client http https postgresql ssh Nginx: listens on port 80, all names/addresses for redirects to https Listens on all addresses, port 443, on names: docs.apollo-af.org (served statically) dash.apollo-af.org (proxied to /grafana_socket/grafana.socket ) Postgresql: Listens on port 5432, all addresses. The user apollo is the only user allowed to connect over the network, and only to the apollo-site database. md5 authentication is used Listens on unix socket. The grafana and postgres users both use peer authentication.","title":"apollosql"},{"location":"developers/projects/apollo-ansible/#apolloweb","text":"NOTE: This server obtains its network info from DHCP!! It might change. We don't know. * Name: apolloweb.urmc-sh.rochester.edu * IPv4 Address (Static): 10.221.3.133/24 * Gateway: 10.221.3.250 * DNS Servers: 172.17.254.30; 172.17.254.130 * Firewalld services: dhcpv6-client http https ssh * Nginx: * listens on port 80, all names/addresses for redirects to https * Listens on all addresses, port 443, on name auth.apollo-af.org : * Location / is proxied to gunicorn, listening on localhost port 8000 * Location /api_client/garmin/ is proxied to gunicorn on localhost, port 8000. Garmin sends data using the following IPs, which are whitelisted: * 98.100.124.0/24 * 98.100.125.0/24 * 204.77.162.0/24 * 204.77.163.0/24","title":"apolloweb"},{"location":"developers/projects/apollo-ansible/#users-and-groups","text":"The following users are added in the common role and should exist on all hosts. They are handled individually by the ansible scripts in the tasks/user_accounts/ directory. Currently the users that should exist on all hosts are: * apage2 (provided by Active Directory in the urmc-sh.rochester.edu domain) * pdragos (provided by Active Directory in the urmc-sh.rochester.edu domain) * apollo (local user) On apollosql , the users nginx and grafana (installed by their respective applications) should both be part of the grafana_socket group. This is necessary to allow nginx and grafana to communicate over a unix socket in a SGID directory.","title":"Users and groups"},{"location":"developers/projects/apollo-ansible/#crypto-and-security-overview","text":"Passwords and keys should be stored in a password manager or ansible-vault'ed. * Postgresql communicates over TLS with self-signed cert. Authentication is either local ( peer ) or md5. * Grafana seems to require a plaintext database password in its configuration file. Care should be taken to ensure that the proper permissions are set on /etc/grafana/grafana.ini . * Nginx has individual TLS certificates for all host names it is responsible for. As of 2020-01-30, we do not have public IPs for the virtual machines; when we do, certbot will be responsible for maintaining these certificates. * A restrictive umask is in place. Be aware of this. * SELinux should work in enforcing mode.","title":"Crypto and Security Overview"},{"location":"developers/projects/apollo-ansible/#deployment","text":"To get running quickly: * Set up your inventory file at hosts/prod/inventory . You'll need an apolloweb host and an apollosql host. * Run ansible-playbook -K deploy_to_prod.yml --vault-password-file /path/to/vault_pass -i hosts/prod/inventory","title":"Deployment"},{"location":"developers/projects/apollo-ansible/#lifecycle-environments","text":"This repository is designed to configure development ( dev ), testing ( test ), and production ( prod ) lifecycle enviornments. To do so, three different inventory files in their respective directories under the hosts/[lifecycle state]/ directory. Variables specific to each lifecycle state may be set in accordance with inventory-based variables ( group_vars , host_vars , etc.) Note: In ansible, group_vars take precedence over variables in roles/[rolename]/defaults/main.yml .","title":"Lifecycle Environments"},{"location":"developers/projects/apollo-ansible/#playbook-flow-current-as-of-2020-01-30","text":"set up all servers ( apolloweb and apollosql with the common role cetup postgresql configure postgres do a hacky work-around to get SSL working set up nginx open ports set up the webapp set up grafana set up the documentation site","title":"Playbook flow (current as of 2020-01-30):"},{"location":"developers/projects/apollo-ansible/#variables","text":"Where to find them: hosts/[lifecycle state]/group_vars sets playbook-wide variables. This should be the primary source for configuration parameters. The playbook itself. This is where some more verbose, static parameters should be set (e.g., pg_hba.conf or the nginx.conf entries. Look at the relevant files to get an idea of the variables you need to set.","title":"Variables:"},{"location":"developers/projects/apollo-ansible/#variables_1","text":"Variables that relate to site-wide or lifecycle-wide configuration are listed below. Complete descriptions of role-specific variables (required or optional) may be found in the respective README.md files. The variables listed below are generally defined in hosts/[lifecycle]/group_vars/all.yml . Variable Description Example lifecycle_state Either 'dev', 'test', or 'prod', depending on the inventory file used. prod apollo_site_database_name The name of the database the main API site will use apollo_site apollo_site_database_user The username that SQLalchemy/flask will connect as apollo apollo_site_database_password a vaulted password to authenticate the postgresql user for the main API site !vault | $ANSIBLE_VAULT;1.1;AES256 36643264643431346165613138326261356335326265353337363762663836653566336135303366 343365366... apollo_site_database_connection_cidr_ip The IPv4 address that the apollo site will connect to its backend database from, for whitelisting purposes 192.168.122.191/24 apollo_site_database_uri The URI that the SQLalchemy should use to connect to the database \"postgresql://{{ apollo_site_database_user }}:{{ apollo_site_database_password }}@apollosql.urmc-sh.rochester.edu:5432/{{ apollo_site_database_name }}\" apollo_monitor_domain The domain name (for grafana) dash.apollo-af.org apollo_monitor_root_url The full URL used for the site. Needed for redirects. https://dash.apollo-af.org/ apollo_monitor_postgresql_backend_host Controls how grafana accesses its backend database /run/postgresql/ apollo_monitor_postgresql_backend_database_name The name of the database grafana uses as its backend grafana apollo_monitor_postgresql_backend_database_username The username grafana connects to its backend database with grafana apollo_monitor_postgresql_backend_database_password The vaulted password grafana uses to connect to its backend database !vault |$ANSIBLE_VAULT;1.1;AES2560 353035646165360356233370... apollo_api_nginx_server_name The name that nginx listens on to proxy to the main site auth.apollo-af.org apollo_docs_nginx_server_name The name that nginx listens on to proxy to the documentation site docs.apollo-af.org apollo_monitor_nginx_server_name The name that nginx listens on to proxy to grafana dash.apollo-af.org","title":"Variables"},{"location":"developers/projects/apollo-ansible/#role-overview","text":"Role Description Pre-requisites apollo_api Sets up flask and gunicorn to serve the main site common, nginxinc.nginx apollo_docs Sets up the static mkdocs documentation site common, nginxinc.nginx apollo_monitor Configures a host to perform monitoring functions (grafana). common, nginxinc.nginx . Requires a a backend database, so some host must have the geerlingguy.postgresql and apollo_pg roles applied as well apollo_pg Configures a host running postgreSQL to function as apollo's long-term data store. Note: the geerlingguy.postgresql role must already be common, geerlingguy.postgresql apollo_scripts Configures a host to run scripts related to geneACTIV, medtronic, REDCap, etc. N/A common Common configuration applied to all hosts, including common software, user accounts, security hardening, etc. N/A geerlingguy.postgresql Configures a host with a postgresql server. Pulled from ansible-galaxy; do not modify. N/A nginxinc.nginx Configures a host with an nginx server. Pulled from ansible-galaxy; do not modify N/A","title":"Role Overview"},{"location":"developers/projects/apollo-ansible/roles/","text":"Roles Look below to find the specifics of a role.","title":"Roles"},{"location":"developers/projects/apollo-ansible/roles/#roles","text":"Look below to find the specifics of a role.","title":"Roles"},{"location":"developers/projects/apollo-ansible/roles/apollo_api/","text":"apollo_api","title":"apollo_api"},{"location":"developers/projects/apollo-ansible/roles/apollo_api/#apollo_api","text":"","title":"apollo_api"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/","text":"apollo_monitor Synopsis This role sets up the monitoring infrastructure (grafana) for the apollo project. It currently sets up grafana. Out of the box, this role will provision datasources, dashboards, and users, as well as configure the server. It will set up some user permissions. Note: To completely restore an apollo_monitor instance, you must copy the grafana.db file and restore the appropriate configuration. Back this file up as necessary. A separate playbook will be developed to dump the grafana.db file to an S3 bucket. READ THIS: Development Notes DNS is not currently setup, especially not for the dev branch. A play may eventually be developed to handle the following (depending on how our PKI plays out), but in order to get TLS working with the appropriate security checks in place, you will have to: On the server: Add apollo_monitor.dev to the hosts file. Binding it to 127.0.0.1 is fine (for now), since grafana set up to listening on all interfaces Add the certificate authority used to sign the TLS dev certificate. This can be found in hosts/dev/files/ . Copy it /etc/pki/ca-trust/source/anchors/ . Run update-ca-trust On the client: Add apollo_monitor.dev to the hosts file with the IP address of the server. Add the certificate authority used to sign the TLS dev certificate (as above, for Fedora; or your distribution's equivalent). Run update-ca-trust (for Fedora, for your distribution's equivalent). Requirements This role targets a CentOS 7 minimal installation with the apollo-af common role applied as a pre-requisite. Adding Users To add a user, add a [user]_account.yml file to the tasks/user_accounts/ directory with the appropriate variables filled out. See tasks/user_accounts/template.yml for an example. Users are added using the API grafana provides. This can get clunky: certian actions return error codes that can be hard to parse in ansible (for example, a 404 is returned when a non-existant user is queried.) Files The role expects two files and two folders in the files/ directory: The [env]_apollo_monitor_server.crt file, containing the appropriate (signed) certificate to use for TLS. The (vaulted) [env]_apollo_monitor_server.key file, containing the corresponding private key. The datasources/ directory, containing: *.yml files describing datasources to be provisioned by the server The dashboards/ directory, containing *.yml files describing dashboard providers *.json files describing dashboards to be provisioned See the grafana docs for more information on provisioning. Variables Global, user-defined variables are listed below. See the template.yml file described in the \"Adding Users\" section for variables related to adding users. Variable: Choices/Defaults: Declared in: Comments: apollo_monitor_grafana_admin_password Format : A vaulted plaintext file containing the \"admin\" account password. defaults/main.yml apollo_monitor_domain Format : FQDN of the grafana server ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor.yml The public facing domain name used to access grafana from a browser apollo_monitor_root_url Format : URL ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor.yml The full public facing url you use in browser, used for redirects and emails apollo_monitor_postgresql_backend_host Hostname or IP ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml The host name for grafana to connect to for it's backend database. apollo_monitor_postgresql_backend_database_name Format : String ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml Name of the backend database to connect to apollo_monitor_postgresql_backend_database_username Format : String ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml Username of the database role grafana should connect as for it's backend. apollo_monitor_postgresql_backend_database_password Format : Vaulted string ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml Vaulted password of the database role grafana should connect as for it's backend. Security Considerations TODO : * evaluate if the vaulted password for apollo_monitor_grafana_admin_password is getting logged anywhere (ansible or grafana) * Evaluate if grafana is storing passwords (user, datasource, etc in plaintext) This role sets up TLS and sets some options in grafana.ini to ensure security. Grafana has built-in brute-force throttling, so fail2ban has not been configured. As of this writing (2019-06-26), it appears that certain API calls must use Basic Auth (read: plaintext) to authenticate (rather than API tokens). This is sub-optimal, but certain tasks can only be automated in this way. Ensure that TLS is working! Reading through various bug reports, I have concluded that security is not a first-class concern of the grafana developers, although it is getting worked on. I am uncertain whether or data source passwords are being stored in plaintext. Network Considerations Nginx should be configured to listen on port 80,443 on the name dash.apollo-af.org and proxy the requests ( TLS only ) to socket that grafana is listening on. The default umask for the servers in this project is restrictive. To allow nginx and grafana to communicate, you must: Set the selinux context for \"/grafana_socket(/.*)?\" to system_u:object_r:httpd_var_run_t:s0 Create a group grafana_socket Add users nginx and grafana to the grafana_socket group Restart nginx (so that the new group takes effect) Create a folder /grafana_socket with owner root , group grafana , and permissions 2770 . Make sure that the appropriate SELinux context is applied.","title":"Apollo monitor"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#apollo_monitor","text":"","title":"apollo_monitor"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#synopsis","text":"This role sets up the monitoring infrastructure (grafana) for the apollo project. It currently sets up grafana. Out of the box, this role will provision datasources, dashboards, and users, as well as configure the server. It will set up some user permissions. Note: To completely restore an apollo_monitor instance, you must copy the grafana.db file and restore the appropriate configuration. Back this file up as necessary. A separate playbook will be developed to dump the grafana.db file to an S3 bucket.","title":"Synopsis"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#read-this-development-notes","text":"DNS is not currently setup, especially not for the dev branch. A play may eventually be developed to handle the following (depending on how our PKI plays out), but in order to get TLS working with the appropriate security checks in place, you will have to: On the server: Add apollo_monitor.dev to the hosts file. Binding it to 127.0.0.1 is fine (for now), since grafana set up to listening on all interfaces Add the certificate authority used to sign the TLS dev certificate. This can be found in hosts/dev/files/ . Copy it /etc/pki/ca-trust/source/anchors/ . Run update-ca-trust On the client: Add apollo_monitor.dev to the hosts file with the IP address of the server. Add the certificate authority used to sign the TLS dev certificate (as above, for Fedora; or your distribution's equivalent). Run update-ca-trust (for Fedora, for your distribution's equivalent).","title":"READ THIS: Development Notes"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#requirements","text":"This role targets a CentOS 7 minimal installation with the apollo-af common role applied as a pre-requisite.","title":"Requirements"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#adding-users","text":"To add a user, add a [user]_account.yml file to the tasks/user_accounts/ directory with the appropriate variables filled out. See tasks/user_accounts/template.yml for an example. Users are added using the API grafana provides. This can get clunky: certian actions return error codes that can be hard to parse in ansible (for example, a 404 is returned when a non-existant user is queried.)","title":"Adding Users"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#files","text":"The role expects two files and two folders in the files/ directory: The [env]_apollo_monitor_server.crt file, containing the appropriate (signed) certificate to use for TLS. The (vaulted) [env]_apollo_monitor_server.key file, containing the corresponding private key. The datasources/ directory, containing: *.yml files describing datasources to be provisioned by the server The dashboards/ directory, containing *.yml files describing dashboard providers *.json files describing dashboards to be provisioned See the grafana docs for more information on provisioning.","title":"Files"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#variables","text":"Global, user-defined variables are listed below. See the template.yml file described in the \"Adding Users\" section for variables related to adding users. Variable: Choices/Defaults: Declared in: Comments: apollo_monitor_grafana_admin_password Format : A vaulted plaintext file containing the \"admin\" account password. defaults/main.yml apollo_monitor_domain Format : FQDN of the grafana server ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor.yml The public facing domain name used to access grafana from a browser apollo_monitor_root_url Format : URL ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor.yml The full public facing url you use in browser, used for redirects and emails apollo_monitor_postgresql_backend_host Hostname or IP ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml The host name for grafana to connect to for it's backend database. apollo_monitor_postgresql_backend_database_name Format : String ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml Name of the backend database to connect to apollo_monitor_postgresql_backend_database_username Format : String ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml Username of the database role grafana should connect as for it's backend. apollo_monitor_postgresql_backend_database_password Format : Vaulted string ../../hosts/[env]/group_vars/apollo_monitor/apollo_monitor_postgresql_backend_details.yml Vaulted password of the database role grafana should connect as for it's backend.","title":"Variables"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#security-considerations","text":"TODO : * evaluate if the vaulted password for apollo_monitor_grafana_admin_password is getting logged anywhere (ansible or grafana) * Evaluate if grafana is storing passwords (user, datasource, etc in plaintext) This role sets up TLS and sets some options in grafana.ini to ensure security. Grafana has built-in brute-force throttling, so fail2ban has not been configured. As of this writing (2019-06-26), it appears that certain API calls must use Basic Auth (read: plaintext) to authenticate (rather than API tokens). This is sub-optimal, but certain tasks can only be automated in this way. Ensure that TLS is working! Reading through various bug reports, I have concluded that security is not a first-class concern of the grafana developers, although it is getting worked on. I am uncertain whether or data source passwords are being stored in plaintext.","title":"Security Considerations"},{"location":"developers/projects/apollo-ansible/roles/apollo_monitor/#network-considerations","text":"Nginx should be configured to listen on port 80,443 on the name dash.apollo-af.org and proxy the requests ( TLS only ) to socket that grafana is listening on. The default umask for the servers in this project is restrictive. To allow nginx and grafana to communicate, you must: Set the selinux context for \"/grafana_socket(/.*)?\" to system_u:object_r:httpd_var_run_t:s0 Create a group grafana_socket Add users nginx and grafana to the grafana_socket group Restart nginx (so that the new group takes effect) Create a folder /grafana_socket with owner root , group grafana , and permissions 2770 . Make sure that the appropriate SELinux context is applied.","title":"Network Considerations"},{"location":"developers/projects/apollo_flask/","text":"apollo_flask A repo to build the OAuth and API website for the apollo project. Overview Apollo's main purpose is to obtain near-real-time data from wearable devices and combine it with self-reported and clinical data with the goal of subjecting it to machine-learning analysis. In order to obtain near-real-time data, we are integrating with providers of such data. Apollo-flask is the part of the project that manages the following: Receiving permission from a data provided (e.g. Garmin or Google Fit) to utilize their API. Provideing platform for our users to grant (and revoke) access to their data via the data provider. Securely storing user credentials, authentication, and authorization data. Receiving and securely storing user data as provided by the data provider. At this time, Garmin Connect is the only data provider implemented. Technologies Used: Python 3 Flask (web framework) Gunicorn (WSGI application server) SQLalchemy (database interconnection library) Pytest (Unit Testing) rauth (Oauth client integration) Nginx (web server) Postgresql 11 (database server) Project Layout File Organization The project is organized, at the top level, into the following directories: apollo_flask : containing the code needed to run the webserver. nginx : containing an nginx configuration file to setup the site. tests : containing unit tests. In the top level directory, there are also some important files: * setup.* : packaging files * wsgi.py : The file to point gunicorn at. The apollo_flask folder's __init__.py contains the code necessary to create the flask app and register blueprints to it, as well as set the application's environment (i.e., testing, development, or production) and load configuration dynamically. The apollo_flask folder also contains flask blueprints for handling oauth and the ingestion of data sent from the garmin health API. Inside the apollo_flask folder, there exists a db folder, containing an __init__.py file that sets up context management for database queries (the session_scope() function) as well as flask commands to initialize the database. The db folder includes a models folder containing data models for user authentication and garmin wellness data, as well as library imports. Data Model The database is broken into schemas handling user authentication and credentials (the garmin_oauth schema) and wellness data (the garmin_wellness schema). Thus, database queries need to be written with the schema name prepended; i.e., SELECT * FROM garmin_wellness.daily_summary The table schema for each of the database schemas is stored in a separate folder, with (generally) separate files for each table. Each file contains an import of the form from apollo_flask.db.models.lib import * which imports various sqlalchemy data types and utilities, as well as declares some apollo_flask-unqiue data types. If most data model classes will require a particular import, this is where it should be stored. Generally, we try to centralize our object-relational mapping around the garmin_oauth.user_id table; both authentication data and currently implemented wellness data reference the user_id.user_id attribute as a foreign key, and sqlalchemy relationships exist between all relevant tables. This means that most operations involving sqlalchemy should be able to query a user and retrieve all relevant data about that user without extra effort. Class and attribute names are written in a style generally consistent with the rest of the Apollo project, except the names of the API endpoints, which are named following the conventions set by Garmin exactly. Garmin itself uses a a fairly verbose (and fairly undocumented ) CamelCase naming convention; thus, when renaming attributes in JSON responses to fit our data model, it is highly likely that some spelling errors will slip through. Be careful. If writing extra data models, be sure to add them to the appropriate __init__.py file so that they are imported with their package. In addition, if more schemas are added the SCHEMA_LIST variable in the apollo_flask/db/__init__.py file must be updated. Authentication Flow Authentication is done via OAuth 1 through the garmin health API. Full details are available via the specification available on the API website. The code handling consent, de-registration, and callbacks is in apollo_flask/garmin_oauth.py . Most of the nitty-gritty is handling by the rauth library. All authentication data, including access tokens, UIDs, request tokens, and active user booleans are stored in the garmin_oauth schema in the database. API Endpoints oauth/garmin/consent: When an end user visits this endpoint (currently linked on the homepage as \"Authorize Garmin Connect\"), it triggers flask to ask for a request token from Garmin. When it receives one, it stores it in the database, and redirects the user to a consent page on the Garmin website along with the public half of the request token. oauth/garmin/callback: After a user has consented on the garmin website, they are redirected to this endpoint with an access token that allows us to access their data. This access token is stored in the database and the user is marked as active. oauth/garmin/deregistration: When a user wishes to revoke access, they must go to the Garmin Connect website and deregister our application. Garmin then POSTs a deregistration response to this endpoint to notify us that this has occured. Currently, this causes the application to mark the user as inactive in the database; in the future, we may require some additional handling. Data Ingestion Flow The Garmin API offers two methods of sending data to clients: push or ping . Currently, we use the push method. When data is synced from a user's device to Garmin Connect, Garmin POSTs a request containing this data (in a JSON format) to our specified API endpoints. One or more data points (typically some form of \"Wellness summary\") is contained in each JSON object. The currently-implemented Garmin API endpoints for apollo_flask all have the prefix api_client/garmin/ . When Flask recieves a request at this endpoint, it dispatches a method via the garmin_api_client blueprint. This method Parses the request into the appropriate atomic parts (e.g., constructs a list of individual activity summaries) For each atomic part, constructs a sqlalchemy object out of the JSON data For each created object, compares it to the existing data in the database, and determines whether the incoming data creates a new record, updates an existing one, or is older than the existing data. Returns a response to the garmin API upon success. Installation Navigate to the project directory and run pip3 install -e . to install the package in editable mode. Requirements The project is written in python 3.6. Other versions of python will probably work, but haven't been tested. Packages Dependencies should be installed automatically with the above command. If they are not, the primary libraries you will need are sqlalchemy, rauth, flask, requests, and pytest. Deployment An ansible playbook/role is forthcoming, after it is decided how the database will be setup. Usage/Invocations Once the web application is properly installed, nginx and gunicorn should be run as daemon processes. Project-specific invocations are given below. Flask After setting the FLASK_APP environment variable to wsgi:app (or equivalent), the database can be initialized with the following command flask init-db Gunicorn Gunicorn should be invoked as gunicorn --error-logfile FILE wsgi:app Gunicorn launches as a daemon process automatically; if you invoke (as above) in an ssh session and put it as a background process, it will persist beyond the session. Testing A blank database, mock client, and a dummy UID (corresponding to the author) is loaded for many of the tests. The tests cannot (currently) be run in parallel; if the database is in use, sqlalchemy will not be able to re-initialize it before running the next test. Testing configuration options and fixtures are declared in the tests/conftest.py file. The test_garmin_api_client suite could use some improvement. Currently, it tests for the presence of a handful of object attributes in the database, as well as for validity of assumptions about sqlalchemy, flask, and the garmin API. This should be expanded with more robust (and perhaps dynamic) test data. To run the entire testing suite, cd into the apollo_site directory and run pytest or python3 -m pytest , depending on your environment. Configuration Configuration data for the flask app should be stored in a apollo_site/instance/config.py file. A sample file is given below; the options set are required . import os GARMIN_CONSUMER_KEY = 'consumer_key' GARMIN_CONSUMER_SECRET = 'consumer_secret' os.environ['DATABASE_URI'] = 'postgresql://postgres@127.0.0.1:5432/apollo_site.db' DEFAULT_DATABASE_URI = 'postgresql://postgres@127.0.0.1:5432/postgres' DATABASE_NAME = 'apollo_site.db' The setup.py and setup.cfg are configuration files for setuptools packaging and pytest , respectively. Web Application By default, gunicorn listens on 127.0.01:8000, and is proxied via nginx. Database Testing The test suite constructs a new database from scratch for each test. This means that the tests (as currently written) cannot be run in parallel; if the database is in use, sqlalchemy will not be able to re-initialize it for the next test. Nginx By default, nginx listens on port 443 (with plain HTTP redirected to 443), and proxies to gunicorn on 127.0.0.1:8000.","title":"apollo_flask"},{"location":"developers/projects/apollo_flask/#apollo_flask","text":"A repo to build the OAuth and API website for the apollo project.","title":"apollo_flask"},{"location":"developers/projects/apollo_flask/#overview","text":"Apollo's main purpose is to obtain near-real-time data from wearable devices and combine it with self-reported and clinical data with the goal of subjecting it to machine-learning analysis. In order to obtain near-real-time data, we are integrating with providers of such data. Apollo-flask is the part of the project that manages the following: Receiving permission from a data provided (e.g. Garmin or Google Fit) to utilize their API. Provideing platform for our users to grant (and revoke) access to their data via the data provider. Securely storing user credentials, authentication, and authorization data. Receiving and securely storing user data as provided by the data provider. At this time, Garmin Connect is the only data provider implemented.","title":"Overview"},{"location":"developers/projects/apollo_flask/#technologies-used","text":"Python 3 Flask (web framework) Gunicorn (WSGI application server) SQLalchemy (database interconnection library) Pytest (Unit Testing) rauth (Oauth client integration) Nginx (web server) Postgresql 11 (database server)","title":"Technologies Used:"},{"location":"developers/projects/apollo_flask/#project-layout","text":"","title":"Project Layout"},{"location":"developers/projects/apollo_flask/#file-organization","text":"The project is organized, at the top level, into the following directories: apollo_flask : containing the code needed to run the webserver. nginx : containing an nginx configuration file to setup the site. tests : containing unit tests. In the top level directory, there are also some important files: * setup.* : packaging files * wsgi.py : The file to point gunicorn at. The apollo_flask folder's __init__.py contains the code necessary to create the flask app and register blueprints to it, as well as set the application's environment (i.e., testing, development, or production) and load configuration dynamically. The apollo_flask folder also contains flask blueprints for handling oauth and the ingestion of data sent from the garmin health API. Inside the apollo_flask folder, there exists a db folder, containing an __init__.py file that sets up context management for database queries (the session_scope() function) as well as flask commands to initialize the database. The db folder includes a models folder containing data models for user authentication and garmin wellness data, as well as library imports.","title":"File Organization"},{"location":"developers/projects/apollo_flask/#data-model","text":"The database is broken into schemas handling user authentication and credentials (the garmin_oauth schema) and wellness data (the garmin_wellness schema). Thus, database queries need to be written with the schema name prepended; i.e., SELECT * FROM garmin_wellness.daily_summary The table schema for each of the database schemas is stored in a separate folder, with (generally) separate files for each table. Each file contains an import of the form from apollo_flask.db.models.lib import * which imports various sqlalchemy data types and utilities, as well as declares some apollo_flask-unqiue data types. If most data model classes will require a particular import, this is where it should be stored. Generally, we try to centralize our object-relational mapping around the garmin_oauth.user_id table; both authentication data and currently implemented wellness data reference the user_id.user_id attribute as a foreign key, and sqlalchemy relationships exist between all relevant tables. This means that most operations involving sqlalchemy should be able to query a user and retrieve all relevant data about that user without extra effort. Class and attribute names are written in a style generally consistent with the rest of the Apollo project, except the names of the API endpoints, which are named following the conventions set by Garmin exactly. Garmin itself uses a a fairly verbose (and fairly undocumented ) CamelCase naming convention; thus, when renaming attributes in JSON responses to fit our data model, it is highly likely that some spelling errors will slip through. Be careful. If writing extra data models, be sure to add them to the appropriate __init__.py file so that they are imported with their package. In addition, if more schemas are added the SCHEMA_LIST variable in the apollo_flask/db/__init__.py file must be updated.","title":"Data Model"},{"location":"developers/projects/apollo_flask/#authentication-flow","text":"Authentication is done via OAuth 1 through the garmin health API. Full details are available via the specification available on the API website. The code handling consent, de-registration, and callbacks is in apollo_flask/garmin_oauth.py . Most of the nitty-gritty is handling by the rauth library. All authentication data, including access tokens, UIDs, request tokens, and active user booleans are stored in the garmin_oauth schema in the database.","title":"Authentication Flow"},{"location":"developers/projects/apollo_flask/#api-endpoints","text":"oauth/garmin/consent: When an end user visits this endpoint (currently linked on the homepage as \"Authorize Garmin Connect\"), it triggers flask to ask for a request token from Garmin. When it receives one, it stores it in the database, and redirects the user to a consent page on the Garmin website along with the public half of the request token. oauth/garmin/callback: After a user has consented on the garmin website, they are redirected to this endpoint with an access token that allows us to access their data. This access token is stored in the database and the user is marked as active. oauth/garmin/deregistration: When a user wishes to revoke access, they must go to the Garmin Connect website and deregister our application. Garmin then POSTs a deregistration response to this endpoint to notify us that this has occured. Currently, this causes the application to mark the user as inactive in the database; in the future, we may require some additional handling.","title":"API Endpoints"},{"location":"developers/projects/apollo_flask/#data-ingestion-flow","text":"The Garmin API offers two methods of sending data to clients: push or ping . Currently, we use the push method. When data is synced from a user's device to Garmin Connect, Garmin POSTs a request containing this data (in a JSON format) to our specified API endpoints. One or more data points (typically some form of \"Wellness summary\") is contained in each JSON object. The currently-implemented Garmin API endpoints for apollo_flask all have the prefix api_client/garmin/ . When Flask recieves a request at this endpoint, it dispatches a method via the garmin_api_client blueprint. This method Parses the request into the appropriate atomic parts (e.g., constructs a list of individual activity summaries) For each atomic part, constructs a sqlalchemy object out of the JSON data For each created object, compares it to the existing data in the database, and determines whether the incoming data creates a new record, updates an existing one, or is older than the existing data. Returns a response to the garmin API upon success.","title":"Data Ingestion Flow"},{"location":"developers/projects/apollo_flask/#installation","text":"Navigate to the project directory and run pip3 install -e . to install the package in editable mode.","title":"Installation"},{"location":"developers/projects/apollo_flask/#requirements","text":"The project is written in python 3.6. Other versions of python will probably work, but haven't been tested.","title":"Requirements"},{"location":"developers/projects/apollo_flask/#packages","text":"Dependencies should be installed automatically with the above command. If they are not, the primary libraries you will need are sqlalchemy, rauth, flask, requests, and pytest.","title":"Packages"},{"location":"developers/projects/apollo_flask/#deployment","text":"An ansible playbook/role is forthcoming, after it is decided how the database will be setup.","title":"Deployment"},{"location":"developers/projects/apollo_flask/#usageinvocations","text":"Once the web application is properly installed, nginx and gunicorn should be run as daemon processes. Project-specific invocations are given below.","title":"Usage/Invocations"},{"location":"developers/projects/apollo_flask/#flask","text":"After setting the FLASK_APP environment variable to wsgi:app (or equivalent), the database can be initialized with the following command flask init-db","title":"Flask"},{"location":"developers/projects/apollo_flask/#gunicorn","text":"Gunicorn should be invoked as gunicorn --error-logfile FILE wsgi:app Gunicorn launches as a daemon process automatically; if you invoke (as above) in an ssh session and put it as a background process, it will persist beyond the session.","title":"Gunicorn"},{"location":"developers/projects/apollo_flask/#testing","text":"A blank database, mock client, and a dummy UID (corresponding to the author) is loaded for many of the tests. The tests cannot (currently) be run in parallel; if the database is in use, sqlalchemy will not be able to re-initialize it before running the next test. Testing configuration options and fixtures are declared in the tests/conftest.py file. The test_garmin_api_client suite could use some improvement. Currently, it tests for the presence of a handful of object attributes in the database, as well as for validity of assumptions about sqlalchemy, flask, and the garmin API. This should be expanded with more robust (and perhaps dynamic) test data. To run the entire testing suite, cd into the apollo_site directory and run pytest or python3 -m pytest , depending on your environment.","title":"Testing"},{"location":"developers/projects/apollo_flask/#configuration","text":"Configuration data for the flask app should be stored in a apollo_site/instance/config.py file. A sample file is given below; the options set are required . import os GARMIN_CONSUMER_KEY = 'consumer_key' GARMIN_CONSUMER_SECRET = 'consumer_secret' os.environ['DATABASE_URI'] = 'postgresql://postgres@127.0.0.1:5432/apollo_site.db' DEFAULT_DATABASE_URI = 'postgresql://postgres@127.0.0.1:5432/postgres' DATABASE_NAME = 'apollo_site.db' The setup.py and setup.cfg are configuration files for setuptools packaging and pytest , respectively.","title":"Configuration"},{"location":"developers/projects/apollo_flask/#web-application","text":"By default, gunicorn listens on 127.0.01:8000, and is proxied via nginx.","title":"Web Application"},{"location":"developers/projects/apollo_flask/#database","text":"","title":"Database"},{"location":"developers/projects/apollo_flask/#testing_1","text":"The test suite constructs a new database from scratch for each test. This means that the tests (as currently written) cannot be run in parallel; if the database is in use, sqlalchemy will not be able to re-initialize it for the next test.","title":"Testing"},{"location":"developers/projects/apollo_flask/#nginx","text":"By default, nginx listens on port 443 (with plain HTTP redirected to 443), and proxies to gunicorn on 127.0.0.1:8000.","title":"Nginx"}]}